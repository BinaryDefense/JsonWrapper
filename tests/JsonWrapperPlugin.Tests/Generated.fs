//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------
namespace rec DataSchema


namespace rec DataSchema


namespace rec DataSchema

type SimpleSchema(jtoken: Newtonsoft.Json.Linq.JToken, serializer: Newtonsoft.Json.JsonSerializer) =
    member this.one
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["one"]

            selectedToken.ToObject<int> serializer
        and set (newValue: int) =
            jtoken.["one"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    member this.two
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["two"]

            selectedToken.ToObject<string> serializer
        and set (newValue: string) =
            jtoken.["two"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    member this.three
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["three"]

            selectedToken.ToObject<System.Guid> serializer
        and set (newValue: System.Guid) =
            jtoken.["three"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    override this.GetHashCode () = jtoken.GetHashCode()

    override this.Equals(objToCompare: obj) =
        match objToCompare with
        | :? Example.IHaveJToken as jTokenToCompare ->
            Newtonsoft.Json.Linq.JToken.DeepEquals(jTokenToCompare.InnerData, jtoken)
        | _ -> false

    ///This allows the class to be pattern matched against
    member this.Deconstruct(one: outref<int>, two: outref<string>, three: outref<System.Guid>) =
        one <- this.one
        two <- this.two
        three <- this.three

    interface Example.IHaveJToken with
        override this.InnerData = jtoken

type DifferentBackingFieldSchema(jtoken: Newtonsoft.Json.Linq.JToken, serializer: Newtonsoft.Json.JsonSerializer) =
    member this.one
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["not_one"]

            selectedToken.ToObject<int> serializer
        and set (newValue: int) =
            jtoken.["not_one"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    member this.two
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["two"]

            selectedToken.ToObject<int> serializer
        and set (newValue: int) =
            jtoken.["two"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    override this.GetHashCode () = jtoken.GetHashCode()

    override this.Equals(objToCompare: obj) =
        match objToCompare with
        | :? Example.IHaveJToken as jTokenToCompare ->
            Newtonsoft.Json.Linq.JToken.DeepEquals(jTokenToCompare.InnerData, jtoken)
        | _ -> false

    ///This allows the class to be pattern matched against
    member this.Deconstruct(one: outref<int>, two: outref<int>) =
        one <- this.one
        two <- this.two

    interface Example.IHaveJToken with
        override this.InnerData = jtoken

type NullableFieldSchema(jtoken: Newtonsoft.Json.Linq.JToken, serializer: Newtonsoft.Json.JsonSerializer) =
    member this.one
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["one"]

            selectedToken.ToObject<System.Nullable<int>> serializer
        and set (newValue: System.Nullable<int>) =
            jtoken.["one"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    member this.two
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["two"]

            selectedToken.ToObject<string> serializer
        and set (newValue: string) =
            jtoken.["two"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    override this.GetHashCode () = jtoken.GetHashCode()

    override this.Equals(objToCompare: obj) =
        match objToCompare with
        | :? Example.IHaveJToken as jTokenToCompare ->
            Newtonsoft.Json.Linq.JToken.DeepEquals(jTokenToCompare.InnerData, jtoken)
        | _ -> false

    ///This allows the class to be pattern matched against
    member this.Deconstruct(one: outref<System.Nullable<int>>, two: outref<string>) =
        one <- this.one
        two <- this.two

    interface Example.IHaveJToken with
        override this.InnerData = jtoken

type NullableMissingFieldSchema(jtoken: Newtonsoft.Json.Linq.JToken, serializer: Newtonsoft.Json.JsonSerializer) =
    member this.one
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["one"]

            if isNull selectedToken then
                Example.MissingJsonFieldException("one", jtoken)
                |> raise
            selectedToken.ToObject<System.Nullable<int>> serializer
        and set (newValue: System.Nullable<int>) =
            jtoken.["one"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    member this.two
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["two"]

            selectedToken.ToObject<int> serializer
        and set (newValue: int) =
            jtoken.["two"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    override this.GetHashCode () = jtoken.GetHashCode()

    override this.Equals(objToCompare: obj) =
        match objToCompare with
        | :? Example.IHaveJToken as jTokenToCompare ->
            Newtonsoft.Json.Linq.JToken.DeepEquals(jTokenToCompare.InnerData, jtoken)
        | _ -> false

    ///This allows the class to be pattern matched against
    member this.Deconstruct(one: outref<System.Nullable<int>>, two: outref<int>) =
        one <- this.one
        two <- this.two

    interface Example.IHaveJToken with
        override this.InnerData = jtoken

type OptionalFieldSchema(jtoken: Newtonsoft.Json.Linq.JToken, serializer: Newtonsoft.Json.JsonSerializer) =
    member this.one
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["one"]

            selectedToken.ToObject<int option> serializer
        and set (newValue: int option) =
            jtoken.["one"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    member this.two
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["two"]

            selectedToken.ToObject<int> serializer
        and set (newValue: int) =
            jtoken.["two"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    override this.GetHashCode () = jtoken.GetHashCode()

    override this.Equals(objToCompare: obj) =
        match objToCompare with
        | :? Example.IHaveJToken as jTokenToCompare ->
            Newtonsoft.Json.Linq.JToken.DeepEquals(jTokenToCompare.InnerData, jtoken)
        | _ -> false

    ///This allows the class to be pattern matched against
    member this.Deconstruct(one: outref<int option>, two: outref<int>) =
        one <- this.one
        two <- this.two

    interface Example.IHaveJToken with
        override this.InnerData = jtoken

type InnerType(jtoken: Newtonsoft.Json.Linq.JToken, serializer: Newtonsoft.Json.JsonSerializer) =
    member this.one
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["one"]

            selectedToken.ToObject<int option> serializer
        and set (newValue: int option) =
            jtoken.["one"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    member this.two
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["two"]

            selectedToken.ToObject<string> serializer
        and set (newValue: string) =
            jtoken.["two"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    override this.GetHashCode () = jtoken.GetHashCode()

    override this.Equals(objToCompare: obj) =
        match objToCompare with
        | :? Example.IHaveJToken as jTokenToCompare ->
            Newtonsoft.Json.Linq.JToken.DeepEquals(jTokenToCompare.InnerData, jtoken)
        | _ -> false

    ///This allows the class to be pattern matched against
    member this.Deconstruct(one: outref<int option>, two: outref<string>) =
        one <- this.one
        two <- this.two

    interface Example.IHaveJToken with
        override this.InnerData = jtoken

type OuterType(jtoken: Newtonsoft.Json.Linq.JToken, serializer: Newtonsoft.Json.JsonSerializer) =
    member this.foo
        with get () =
            ///Hi i'm a comment
            let selectedToken = jtoken.["foo"]

            selectedToken.ToObject<InnerType> serializer
        and set (newValue: InnerType) =
            jtoken.["foo"] <- Newtonsoft.Json.Linq.JToken.FromObject(newValue, serializer)

    override this.GetHashCode () = jtoken.GetHashCode()

    override this.Equals(objToCompare: obj) =
        match objToCompare with
        | :? Example.IHaveJToken as jTokenToCompare ->
            Newtonsoft.Json.Linq.JToken.DeepEquals(jTokenToCompare.InnerData, jtoken)
        | _ -> false

    ///This allows the class to be pattern matched against
    member this.Deconstruct(foo: outref<InnerType>) = foo <- this.foo

    interface Example.IHaveJToken with
        override this.InnerData = jtoken
